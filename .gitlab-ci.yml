# Main CI/CD pipeline
default:
  retry: 0  # job is not retried if failed
  interruptible: true  # by default jobs should be canceled when a newer pipeline starts before jobs complete

stages:
  - build   # when pushing on a branch only
  - test    # when pushing on a branch only
  - deploy  # when pushing on a branch: publish coverage pages; when pushing a tag: try to release

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE != "push"
      when: never
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH

# Check env & self-update conda before anything
.update_conda:
  stage: .pre
  retry: 1
  script:
    - '[[ "$CI_DEBUG" == "1" ]] && env || true'
    - conda update --yes conda
    - '[[ "$CI_DEBUG" == "1" ]] && conda info || true'

# Assign base job to different CI machines
update_conda_macos:
  extends: .update_conda
  tags:
    - macos
    - shell
  rules:
    - if: $CI_COMMIT_BRANCH  # job not needed for latter deploy jobs (executed on linux only)

update_conda_linux:
  extends: .update_conda
  tags:
    - linux
    - shell
  # leave this job for latter deploy jobs (executed on linux only & using conda)

# Base job for jobs looping on Python environment and testing different OS
.one_for_each_python_version_and_runner_os:
  parallel:
    matrix:
      # TODO? also test on a virtual env with minimal version of requirements (>=X.Y.Z --> ==X.Y.Z)
      - PYTHON_VERSION: ['3.7', '3.8', '3.9'] # 3.10
        CI_RUNNER_TAG: ['macos', 'linux']
  variables:
    CONDA_ENV_NAME: 'leaspy_env_${PYTHON_VERSION}_${CI_COMMIT_BRANCH}'
  tags:
    - $CI_RUNNER_TAG  # new possibility since Gitlab Runner 14.1
    - shell
  rules:
    - if: $CI_COMMIT_BRANCH

# Create proper conda environments for tests
create_conda_envs:
  stage: build
  extends: .one_for_each_python_version_and_runner_os
  retry: 2  # some temporary fail occur so retry!
  interruptible: false
  script:
    # use 'create --yes' to force re-creation of env if it already exists (instead of '|| true' that just continues if env already exists)
    - conda create --yes python=$PYTHON_VERSION --name $CONDA_ENV_NAME || true
    - conda activate $CONDA_ENV_NAME
    # TODO? use conda install --update-all --file ...
    - pip install -U -r requirements.txt
    - pip install -U -r requirements_dev.txt

## only delete the created conda environment for branch when in a MR
## TODO? always delete them? (in a `after_script` section)
#remove_conda_envs:
#  stage: .post
#  extends: .one_for_each_python_version_and_runner_os
#  retry: 2
#  interruptible: false
#  rules:
#    - if: $CI_MERGE_REQUEST_ID
#  script:
#    - conda env remove --yes --name $CONDA_ENV_NAME

# Run the whole test suite and report results
tests:
  stage: test
  extends: .one_for_each_python_version_and_runner_os
  variables:
    COVERAGE_HTML_REPORT_TITLE_SUB: 's/^title = Leaspy - (.+)$/title = Leaspy :: ${CI_COMMIT_BRANCH} - \1 (Python ${PYTHON_VERSION})/'
    ARTIFACTS_SUFFIX: '_${CI_RUNNER_TAG}_${PYTHON_VERSION}'
  script:
    - conda activate $CONDA_ENV_NAME
    - python --version
    - pip freeze
    # Customize the title of code coverage HTML report
    - sed -i.bak -E "$COVERAGE_HTML_REPORT_TITLE_SUB" .coveragerc
    - pytest --cov --cov-context=test --cov-report=html:htmlcov${ARTIFACTS_SUFFIX} --cov-report=xml:coverage${ARTIFACTS_SUFFIX}.xml --cov-report=term --junitxml=tests${ARTIFACTS_SUFFIX}.xml tests/
  coverage: '/^TOTAL(?:\s+.*){2}\s+(\d+(?:\.\d+)?\%)$/'
  artifacts:
    when: always  # to import reports even if failed
    paths:
      # for people to browse if they want (in addition to Gitlab tool)
      - htmlcov${ARTIFACTS_SUFFIX}/
    reports:
      # these reports will be directly integrated to Gitlab (MR)
      cobertura: coverage${ARTIFACTS_SUFFIX}.xml
      junit: tests${ARTIFACTS_SUFFIX}.xml

# Deploy coverage pages
pages:
  stage: deploy
  retry: 1 # may fail due to Gitlab, retry
  rules:
    - if: $CI_COMMIT_BRANCH # == $CI_DEFAULT_BRANCH
  tags:
    - shell  # arbitrary choice...
  dependencies:
    - tests
  script:
    - mkdir -p public #/coverage/
    # Only publish the Python 3.9 HTML code coverage report (upload in `coverage` top folder since it would always be overwritten anyway)
    - mv htmlcov_linux_3.9 public/coverage #/$CI_COMMIT_BRANCH
  artifacts:
    paths:
      - public/

# Dynamically get the package metadata (especially the pkg version, as registered in the dedicated Python file)
# and store them as a dedicated .env file so they are accessible in later release jobs for conditional execution
prepare_metadata:
  stage: .pre
  rules:
    - if: $CI_COMMIT_TAG
  tags:
    - shell  # arbitrary choice...
  variables:
    VERSION_PYTHON_FILE: leaspy/__init__.py
    VERSION_REGEX: '^__version__\s*=\s*[\x27"](.+)[\x27"].*$'  # \x27 is for single quote
    VERSION_DEV_SUFFIX_REGEX: '[^0-9]?(dev|alpha|beta|pre|rc).*$'  # TODO? also handle case of ".post*" suffixed releases?
    PKG_METADATA_FILE: package.env
  script:
    - echo "TAG_WITHOUT_PREFIX=${CI_COMMIT_TAG#v}" > $PKG_METADATA_FILE
    - PKG_VERSION=$(sed -n -E "s/${VERSION_REGEX}/\1/p" $VERSION_PYTHON_FILE)
    - PKG_VERSION_WITHOUT_DEV_SUFFIX=$(echo $PKG_VERSION | sed -E "s/${VERSION_DEV_SUFFIX_REGEX}//")
    - echo "PKG_VERSION=$PKG_VERSION" >> $PKG_METADATA_FILE
    - echo "PKG_VERSION_WITHOUT_DEV_SUFFIX=$PKG_VERSION_WITHOUT_DEV_SUFFIX" >> $PKG_METADATA_FILE
    - cat $PKG_METADATA_FILE
  artifacts:
    reports:
      dotenv: $PKG_METADATA_FILE

# Code quality & static application security pipelines from Gitlab
include:
  # https://docs.gitlab.com/ee/user/project/merge_requests/code_quality.html
  - template: Code-Quality.gitlab-ci.yml
  # https://docs.gitlab.com/ee/user/application_security/sast/
  - template: Security/SAST.gitlab-ci.yml

code_quality:
  rules:
    - if: $CODE_QUALITY_DISABLED
      when: never
    - if: $CI_COMMIT_BRANCH  # not on tags...
  tags:
    - linux  # must have docker
    - shell  # but don't do docker in docker (slow)...
  needs: []  # no dependencies (docker execution)
  artifacts:
    when: always
    paths: [gl-code-quality-report.json]

sast:
  variables:
    SAST_EXCLUDED_ANALYZERS: eslint  # some js in browser...
    SAST_EXCLUDED_PATHS: 'build, dist, docs, tests' # browser, example
  tags:
    - docker
  needs: []  # no dependencies (docker execution)

# Trigger child pipeline for conditional release jobs
releases:
  stage: deploy
  rules:
    - if: $CI_COMMIT_TAG
  needs: # `dependencies` is not implemented for trigger jobs (cf. https://docs.gitlab.com/ee/ci/pipelines/multi_project_pipelines.html#trigger-job-configuration-keywords)
    # needed to recover the env variables dynamically loaded before and propagate them to child pipeline
    - prepare_metadata
    # also wait for this one to continue, even if no artifacts needed here unlike first dependency
    - update_conda_linux
  variables:
    # we have to explicitly (re)define variables (reloaded from dotenv) we want to propage to child pipeline here
    TAG_WITHOUT_PREFIX: $TAG_WITHOUT_PREFIX
    PKG_VERSION: $PKG_VERSION
    PKG_VERSION_WITHOUT_DEV_SUFFIX: $PKG_VERSION_WITHOUT_DEV_SUFFIX
  trigger:
    include: .releases.gitlab-ci.yml
    strategy: depend
